# https://cmake.org/cmake/help/latest/module/FindCUDA.html: 3.10 supports CUDA
# asa first-class language:
cmake_minimum_required(VERSION 3.10)

project(Lighthouse2)

# Module and Config searches look in the cmake subdirectory first:
set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake" "${CMAKE_MODULE_PATH}")
set(CMAKE_PREFIX_PATH "${PROJECT_SOURCE_DIR}/cmake" "${CMAKE_PREFIX_PATH}")

# External dependencies bundled with the source:
add_subdirectory("lib/glad")
add_subdirectory("lib/half2.1.0")
add_subdirectory("lib/tinyxml2")
add_subdirectory("lib/tinygltf")
add_subdirectory("lib/tinyobjloader")
add_subdirectory("lib/imgui")

# Platform configuration goes first:
add_subdirectory("lib/platform")
add_subdirectory("lib/RenderSystem")
# HACK! Circular dependency on project *headers*
target_include_directories(Platform PRIVATE "lib/RenderSystem")
# Note that there is a rather peculiar dependency mechanism. Things defined in
# system.h are implemented in platform.cpp, and headers are shared between
# lib/platform and lib/RenderSystem making dependency management ever so
# slightly less elegant.

# Include cross-compatible BSDF implementation:
add_subdirectory("lib/sharedBSDFs")

# Include CUDA support headers:
add_subdirectory("lib/CUDA")

# Include RenderCores:
file(GLOB cores "lib/RenderCore_*")
foreach(core IN LISTS cores)
  if(NOT EXISTS "${core}/CMakeLists.txt")
    message(
      WARNING "${core} does not contain CMakeLists.txt, it will not be built.")
    continue()
  endif()

  add_subdirectory(${core})
  get_filename_component(core_name ${core} NAME)
  # Collect target folders for runtime "linking" (rpath):
  list(APPEND core_folders $<TARGET_FILE_DIR:${core_name}>)
endforeach()

# Include apps:
file(GLOB app_directories "apps/*")
foreach(app IN LISTS app_directories)
  if(NOT EXISTS "${app}/CMakeLists.txt")
    message(
      WARNING "${app} does not contain CMakeLists.txt, it will not be built.")
    continue()
  endif()

  add_subdirectory(${app})
endforeach()
